#!/bin/bash

# Vulnerability scanning module for BountyX

# Run vulnerability scanning
run_vuln_scan() {
    echo -e "${GREEN}Running Vulnerability Scanning against ${BLUE}$TARGET${NC}"
    
    local start_time=$(date +%s)
    
    setup_tor
    
    # Create vulnerability scan output directory
    mkdir -p "$OUTPUT_DIR/vulnerabilities"
    
    local target_list="$OUTPUT_DIR/vulnerabilities/targets.txt"
    
    # Determine targets for vulnerability scanning
    if [[ -f "$OUTPUT_DIR/livehosts/alive_hosts.txt" && -s "$OUTPUT_DIR/livehosts/alive_hosts.txt" ]]; then
        cp "$OUTPUT_DIR/livehosts/alive_hosts.txt" "$target_list"
        echo -e "${YELLOW}Using live hosts from previous scan...${NC}"
    else
        # Add both http and https if the target is a domain
        local target_type=$(get_target_type "$TARGET")
        if [[ "$target_type" == "domain" ]]; then
            echo "http://$TARGET" > "$target_list"
            echo "https://$TARGET" >> "$target_list"
            echo -e "${YELLOW}No live hosts found, using main target with http and https...${NC}"
        else
            echo "$TARGET" > "$target_list"
        fi
    fi
    
    # Ensure target list is not empty
    if [[ ! -s "$target_list" || $(grep -v '^$' "$target_list" | wc -l) -eq 0 ]]; then
        echo "$TARGET" > "$target_list"
        echo -e "${YELLOW}Target list was empty, using main target...${NC}"
    fi
    
    local nuclei_output="$OUTPUT_DIR/vulnerabilities/nuclei_output.json"
    local basic_scan_output="$OUTPUT_DIR/vulnerabilities/basic_scan.json"
    local combined_output="$OUTPUT_DIR/vulnerabilities/all_vulnerabilities.json"
    
    # Use nuclei if available
    if command_exists "nuclei"; then
        echo -e "${YELLOW}Running nuclei scanner...${NC}"
        nuclei -l "$target_list" -o "$nuclei_output" -json
        
        if [[ -f "$nuclei_output" ]]; then
            cp "$nuclei_output" "$combined_output"
        fi
    else
        echo -e "${YELLOW}nuclei not found, using basic vulnerability scanning...${NC}"
        
        # Initialize JSON output
        echo "{\"vulnerabilities\": [" > "$basic_scan_output"
        local first_entry=true
        
        # Read each target
        while read -r target; do
            echo -e "${YELLOW}Scanning ${BLUE}$target${NC}"
            
            # Basic SSL/TLS scan
            if [[ "$target" == https://* ]]; then
                echo -e "${YELLOW}Checking SSL/TLS configuration...${NC}"
                local ssl_issues=false
                local ssl_output=$(timeout 10 openssl s_client -connect $(echo "$target" | sed 's|https://||'):443 -servername $(echo "$target" | sed 's|https://||') 2>/dev/null)
                
                # Check for SSL/TLS vulnerabilities
                if echo "$ssl_output" | grep -q "Protocol  : SSLv3"; then
                    ssl_issues=true
                    if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                    first_entry=false
                    cat <<EOF >> "$basic_scan_output"
{
    "name": "SSLv3 Supported (POODLE)",
    "severity": "high",
    "description": "The server supports SSLv3 which is vulnerable to the POODLE attack",
    "url": "$target",
    "recommendation": "Disable SSLv3 support on the server"
}
EOF
                fi
                
                if echo "$ssl_output" | grep -q "Protocol  : TLSv1.0"; then
                    ssl_issues=true
                    if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                    first_entry=false
                    cat <<EOF >> "$basic_scan_output"
{
    "name": "TLSv1.0 Supported",
    "severity": "medium",
    "description": "The server supports TLSv1.0 which is outdated and has known security issues",
    "url": "$target",
    "recommendation": "Update to TLSv1.2 or higher"
}
EOF
                fi
                
                # Check for weak ciphers
                if echo "$ssl_output" | grep -q "RC4\|DES\|NULL"; then
                    ssl_issues=true
                    if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                    first_entry=false
                    cat <<EOF >> "$basic_scan_output"
{
    "name": "Weak SSL/TLS Ciphers",
    "severity": "high",
    "description": "The server supports weak ciphers (RC4, DES, NULL) which are vulnerable to attacks",
    "url": "$target",
    "recommendation": "Disable weak ciphers and use strong, modern ciphers only"
}
EOF
                fi
                
                if ! $ssl_issues; then
                    echo -e "${GREEN}No basic SSL/TLS issues found${NC}"
                fi
            fi
            
            # Check for missing security headers
            echo -e "${YELLOW}Checking security headers...${NC}"
            local headers=$(curl -s -I -L -k "$target" | tr -d '\r')
            local security_issues=false
            
            # Check for missing security headers
            if ! echo "$headers" | grep -qi "X-XSS-Protection"; then
                security_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Missing X-XSS-Protection Header",
    "severity": "low",
    "description": "The X-XSS-Protection header is not set",
    "url": "$target",
    "recommendation": "Add X-XSS-Protection: 1; mode=block header to responses"
}
EOF
            fi
            
            if ! echo "$headers" | grep -qi "X-Frame-Options"; then
                security_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Missing X-Frame-Options Header",
    "severity": "low",
    "description": "The X-Frame-Options header is not set, making the site potentially vulnerable to clickjacking",
    "url": "$target",
    "recommendation": "Add X-Frame-Options: DENY or SAMEORIGIN header to responses"
}
EOF
            fi
            
            if ! echo "$headers" | grep -qi "Content-Security-Policy"; then
                security_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Missing Content-Security-Policy Header",
    "severity": "medium",
    "description": "The Content-Security-Policy header is not set",
    "url": "$target",
    "recommendation": "Implement a Content Security Policy to prevent XSS and other injection attacks"
}
EOF
            fi
            
            if ! echo "$headers" | grep -qi "Strict-Transport-Security" && [[ "$target" == https://* ]]; then
                security_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Missing HTTP Strict Transport Security Header",
    "severity": "medium",
    "description": "The Strict-Transport-Security header is not set for HTTPS connection",
    "url": "$target",
    "recommendation": "Add Strict-Transport-Security header with a long max-age value"
}
EOF
            fi
            
            if ! echo "$headers" | grep -qi "X-Content-Type-Options"; then
                security_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Missing X-Content-Type-Options Header",
    "severity": "low",
    "description": "The X-Content-Type-Options header is not set",
    "url": "$target",
    "recommendation": "Add X-Content-Type-Options: nosniff header to responses"
}
EOF
            fi
            
            if ! $security_issues; then
                echo -e "${GREEN}No security header issues found${NC}"
            fi
            
            # Check for information disclosure
            echo -e "${YELLOW}Checking for information disclosure...${NC}"
            local body=$(curl -s -L -k "$target")
            local info_issues=false
            
            # Check for server information
            local server_header=$(echo "$headers" | grep -i "Server:")
            if [[ -n "$server_header" && "$server_header" != *"Server: "* ]]; then
                info_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Server Information Disclosure",
    "severity": "low",
    "description": "The server is revealing detailed version information: ${server_header}",
    "url": "$target",
    "recommendation": "Configure the server to hide detailed version information"
}
EOF
            fi
            
            # Check for common patterns in the body
            if echo "$body" | grep -qi "SQL syntax\|SQL error\|mysql_fetch\|ORA-[0-9]\|postgres\|ODBC"; then
                info_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "SQL Error Disclosure",
    "severity": "high",
    "description": "SQL errors are being disclosed to users, potentially revealing database information",
    "url": "$target",
    "recommendation": "Implement proper error handling to not expose database errors to users"
}
EOF
            fi
            
            if echo "$body" | grep -qi "Exception\|Stack trace\|Fatal error\|Parse error"; then
                info_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Application Error Disclosure",
    "severity": "medium",
    "description": "Application errors or stack traces are being exposed to users",
    "url": "$target",
    "recommendation": "Implement proper error handling to catch and sanitize all errors"
}
EOF
            fi
            
            if echo "$body" | grep -qi "admin\|root\|password\|config"; then
                info_issues=true
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Sensitive Information in HTML",
    "severity": "medium",
    "description": "Potentially sensitive information found in HTML source",
    "url": "$target",
    "recommendation": "Review source code to ensure no sensitive data is included in HTML comments or attributes"
}
EOF
            fi
            
            if ! $info_issues; then
                echo -e "${GREEN}No information disclosure issues found${NC}"
            fi
            
            # Check robots.txt for sensitive paths
            if curl -s -L -k "$target/robots.txt" | grep -qi "admin\|config\|backup\|login\|private"; then
                if ! $first_entry; then echo "," >> "$basic_scan_output"; fi
                first_entry=false
                cat <<EOF >> "$basic_scan_output"
{
    "name": "Sensitive Paths in robots.txt",
    "severity": "low",
    "description": "robots.txt contains references to potentially sensitive paths",
    "url": "$target/robots.txt",
    "recommendation": "Review robots.txt and ensure it does not disclose sensitive paths"
}
EOF
            fi
            
        done < "$target_list"
        
        # Finalize JSON output
        echo "]}" >> "$basic_scan_output"
        
        # Create a valid JSON even if no vulnerabilities found
        if $first_entry; then
            echo "{\"vulnerabilities\": []}" > "$basic_scan_output"
        fi
        
        # Copy to the combined output
        cp "$basic_scan_output" "$combined_output"
    fi
    
    local total_vulns=$(jq '.vulnerabilities | length' "$combined_output" 2>/dev/null || echo "0")
    echo -e "${GREEN}Vulnerability scanning completed! Found ${BLUE}$total_vulns${GREEN} potential vulnerabilities.${NC}"
    echo -e "${GREEN}Results saved to ${BLUE}$combined_output${NC}"
    
    local end_time=$(date +%s)
    print_elapsed_time $start_time $end_time
    
    # If interactive mode, prompt to continue
    if [[ -z "$SCAN_TYPE" || "$SCAN_TYPE" == "vulnscan" ]]; then
        echo -e "Press Enter to return to the main menu..."
        read
        show_menu
    fi
}
